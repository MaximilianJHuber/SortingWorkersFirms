"""
    solveS(model)

This function iterates on equation (3) until convergence. 

##### Returns

* `S::Array{Float64,3}`: Surplus as a function of x, y, z
* `l::Array{Float64,1}`: Worker density as a function of x
* `p::Array{Float64,3}`: Production as a function of x, y, z
* `b::Array{Float64,1}`: Home production as a function of x
* `Speriod::Array{Float64,3}`: Period surplus as a function of x, y, z
* `Q::Array{Float64,2}`: Transition probabilities from z to z'

"""
function solveS(model)
    
    @unpack β1, β2, c0, c1, α, ω, r, δ, f0, p1, p2, p3, p4, p5, p6, σ, ρ, s, dt, ϵ, Nx, Ny, Nz,
        Gridx, Gridy, Gridz, Grida = model

    #worker-type distriution
    l = @. Gridx ^ (β1 - 1) * (1 - Gridx) ^ (β2 - 1)
    l = Nx * l / sum(l) #normalization from code

    #production function, 3d array in x, y, z
    p = [f0 * exp.(σ*z) * (p1 + p2*x + p3*y + p4*x^2 + p5*y^2 + p6 * x * y) * dt 
        for x in Gridx, y in Gridy, z in Gridz]

    #home production, 1d array in x
    b = 0.7 * [maximum(p[i, :, convert(Int,(Nz+1)/2)]) 
        for i in 1:length(Gridx)]

    #(period) surplus function initialized at deterministic steady state, 3d array in x, y, z
    Speriod = [(p[i, j, k] - b[i]) 
        for i in 1:length(Gridx), j in 1:length(Gridy), k in 1:length(Gridz)]
    S = (1 + r)/(r + δ) * Speriod

    #transition probabilities for z 
    Q = @. exp(-1/(2*(1 - ρ^2)) * (Gridz^2 + Gridz'^2 - 2 * ρ * Gridz * Gridz'))
    Q = Q ./ sum(Q, 2);
    #TODO check probabilities!

    
    #iterate on equation (3)
    error = 1.
    iteration = 0

    Sold = similar(S)
    copy!(Sold, S)
    
    while (error > 1e-8)
         
        for j in 1:Ny
            @views S[:, j, :] = Sold[:, j, :] * Q
        end
        
        S = Speriod + (1 - δ)/(1 + r) * S
        error = maximum(abs.(S - Sold))
        copy!(Sold, S)
        iteration += 1
    end

    return (S, l, p, b, Speriod, Q)
end